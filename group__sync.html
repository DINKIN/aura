<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>aura: The synchronous API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">aura
   &#160;<span id="projectnumber">0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__sync.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">The synchronous API</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga5b6475daecfc524b94d47b451093e4f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sync.html#ga5b6475daecfc524b94d47b451093e4f7">aura_wait_status</a> (struct aura_node *node, int status)</td></tr>
<tr class="separator:ga5b6475daecfc524b94d47b451093e4f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3183c727af1aaca6dffc6ade4e015bd3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sync.html#ga3183c727af1aaca6dffc6ade4e015bd3">aura_call_raw</a> (struct aura_node *node, int id, struct <a class="el" href="structaura__buffer.html">aura_buffer</a> **retbuf,...)</td></tr>
<tr class="separator:ga3183c727af1aaca6dffc6ade4e015bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96078cef8443a128ab310b4a2385b94b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sync.html#ga96078cef8443a128ab310b4a2385b94b">aura_call</a> (struct aura_node *node, const char *name, struct <a class="el" href="structaura__buffer.html">aura_buffer</a> **retbuf,...)</td></tr>
<tr class="separator:ga96078cef8443a128ab310b4a2385b94b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a4a8a76644410f3e1a1b2a18531c9b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sync.html#ga6a4a8a76644410f3e1a1b2a18531c9b9">aura_enable_sync_events</a> (struct aura_node *node, int count)</td></tr>
<tr class="separator:ga6a4a8a76644410f3e1a1b2a18531c9b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e49c5b1ff963835e12eacd49b11922a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sync.html#ga5e49c5b1ff963835e12eacd49b11922a">aura_get_pending_events</a> (struct aura_node *node)</td></tr>
<tr class="separator:ga5e49c5b1ff963835e12eacd49b11922a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabab6f720480063cc86a02c0ee9b26850"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sync.html#gabab6f720480063cc86a02c0ee9b26850">aura_get_next_event</a> (struct aura_node *node, const struct aura_object **obj, struct <a class="el" href="structaura__buffer.html">aura_buffer</a> **retbuf)</td></tr>
<tr class="separator:gabab6f720480063cc86a02c0ee9b26850"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>One of the core things of aura is the export table, or etable for short. A node 'exports' a table of 'events' and 'methods' that it provides. This is all done by the transport in the main event loop. Once aura receives and compiles the table of available objects the node changes the state to indicate that it is ready to accept calls and deliver incoming events. If the node goes offline for some reason aura will read the export table again once it goes online.</p>
<p>A 'method' represents a simple remote function. It accepts several arguments and returns several results e.g. it looks just like a function call in lua:</p>
<p>a, b, c = function(arg1, arg2)</p>
<p>The method can be called either synchronously using (See <a class="el" href="group__sync.html#ga96078cef8443a128ab310b4a2385b94b">aura_call()</a> and <a class="el" href="group__sync.html#ga3183c727af1aaca6dffc6ade4e015bd3">aura_call_raw()</a> or asynchronously using <a class="el" href="group__async.html#ga98dcf314a2f2b851bac5b3784e8557c2">aura_start_call()</a> or <a class="el" href="group__async.html#ga24fbf448f9be81cdbd71ec5c7e25177c">aura_start_call_raw()</a>. This section covers only synchronous API.</p>
<p>Let's start with the simplest synchronous example for calling remote functions. </p><div class="fragment"><div class="line"> <span class="keywordtype">int</span> ret;</div>
<div class="line"> <span class="keyword">struct </span><a class="code" href="structaura__buffer.html">aura_buffer</a> *retbuf;</div>
<div class="line"> <span class="comment">// Different transports have different options!</span></div>
<div class="line"> <span class="keyword">struct </span>aura_node *node = <a class="code" href="group__node.html#ga5cd310198b9c3c4611a33891df799b62">aura_open</a>(<span class="stringliteral">&quot;dummy&quot;</span>, 1, 2, 3);</div>
<div class="line"> <span class="keywordflow">if</span> (!node) {</div>
<div class="line">    fprintf(<span class="stringliteral">&quot;err: failed to open node\n&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> -1;</div>
<div class="line"> }</div>
<div class="line"></div>
<div class="line"> <a class="code" href="group__sync.html#ga5b6475daecfc524b94d47b451093e4f7">aura_wait_status</a>(node, AURA_STATUS_ONLINE);</div>
<div class="line"></div>
<div class="line"> ret = <a class="code" href="group__sync.html#ga96078cef8443a128ab310b4a2385b94b">aura_call</a>(node, <span class="stringliteral">&quot;echo16&quot;</span>, &amp;retbuf, 128);</div>
<div class="line"> <span class="keywordflow">if</span> (0 == ret) {</div>
<div class="line">    ret = <a class="code" href="group__retparse.html#ga9ba5717e55cc9c86046ba93977f8af8c">aura_buffer_get_u16</a>(retbuf);</div>
<div class="line">    printf(<span class="stringliteral">&quot;Call succeeded - we got %d from device\n&quot;</span>, ret);</div>
<div class="line">    <a class="code" href="group__bufapi.html#gad0e9273ef9f4e3ab41708be4d58ababa">aura_buffer_release</a>(retbuf);</div>
<div class="line"> }</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__node.html#ga5454b43fb0f8f19d2c6bf3fd1e373b38">aura_close</a>(node);</div>
</div><!-- fragment --><p>That's it? Thought it would be harder?</p>
<p>Events, on the contrary represent something that happened on the remote side. E.g. a timer expired, or a user pressed a button and so on. Events can deliver arbitrary payload. Just like returning function arguments. Normally events make sense if you use asynchronous API.</p>
<p>However, aura provides a way to handle events in synchronous way. By default the core will discard any incoming events unless they have an associated callback. If you want to process events in the synchronous way you have to first call <a class="el" href="group__sync.html#ga6a4a8a76644410f3e1a1b2a18531c9b9">aura_enable_sync_events()</a> and specify the queue size. Up to count incoming events will be queued this way.</p>
<p>Once event queuing is enabled you can read the next event with <a class="el" href="group__sync.html#gabab6f720480063cc86a02c0ee9b26850">aura_get_next_event()</a> and aura_get_next_event_timeout(). These functions may block until the next event arrives.</p>
<p>You can also get <a class="el" href="group__sync.html#ga5e49c5b1ff963835e12eacd49b11922a">aura_get_pending_events()</a> to find out the number of queued events. If it is 0 - <a class="el" href="group__sync.html#gabab6f720480063cc86a02c0ee9b26850">aura_get_next_event()</a> will block.</p>
<p>Objects (methods and events alike) are stored internally in a struct aura_object, enumerated from 0 to n. You can either do calls and set callbacks using object names (they are searched using a hash table, that's pretty fast) or via their ids. Beware, though: If the node represents a hardware device, it goes offline for a firmware upgrade and when it comes back to life it has a different export table and the id for the same method may change. Calling by name allows you to avoid conflicts. You get the idea, so don't shoot yourself in the knee!</p>
<p>For something advanced usage - have a look at the async API that is way more powerful. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga96078cef8443a128ab310b4a2385b94b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int aura_call </td>
          <td>(</td>
          <td class="paramtype">struct aura_node *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structaura__buffer.html">aura_buffer</a> **&#160;</td>
          <td class="paramname"><em>retbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Synchronously call a remote method of node identified by name. If the call succeeds, retbuf will be the pointer to <a class="el" href="structaura__buffer.html">aura_buffer</a> containing the values. It's your responsibility to call <a class="el" href="group__bufapi.html#gad0e9273ef9f4e3ab41708be4d58ababa">aura_buffer_release()</a> on the retbuf after you are done working with resulting values</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td></td></tr>
    <tr><td class="paramname">name</td><td></td></tr>
    <tr><td class="paramname">retbuf</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="aura_8c_source.html#l00666">666</a> of file <a class="el" href="aura_8c_source.html">aura.c</a>.</p>

<p>References <a class="el" href="aura_8c_source.html#l00412">aura_core_call()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3183c727af1aaca6dffc6ade4e015bd3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int aura_call_raw </td>
          <td>(</td>
          <td class="paramtype">struct aura_node *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structaura__buffer.html">aura_buffer</a> **&#160;</td>
          <td class="paramname"><em>retbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Synchronously call an object identified by id. If the call succeeds, retbuf will be the pointer to <a class="el" href="structaura__buffer.html">aura_buffer</a> containing the values. It's your responsibility to call <a class="el" href="group__bufapi.html#gad0e9273ef9f4e3ab41708be4d58ababa">aura_buffer_release()</a> on the retbuf after you are done working with resulting values</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td></td></tr>
    <tr><td class="paramname">id</td><td></td></tr>
    <tr><td class="paramname">retbuf</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="aura_8c_source.html#l00626">626</a> of file <a class="el" href="aura_8c_source.html">aura.c</a>.</p>

<p>References <a class="el" href="aura_8c_source.html#l00412">aura_core_call()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6a4a8a76644410f3e1a1b2a18531c9b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void aura_enable_sync_events </td>
          <td>(</td>
          <td class="paramtype">struct aura_node *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable synchronous event processing.</p>
<p>Call this function to make the node queue up to count events in an internal buffer to be read out. By default the node does not queue any events for synchronous readout and drops them immediately if no callbacks are installed to catch this event. If the number of events in this queue reaches count - events will be dropped (oldest first)</p>
<p>To disable synchronous event processing completely - call this function with count=0</p>
<p>Adding a callback for an event is not recommended if you use this API, although possible. It will just prevent events from being queued here - instead your callback will be fired.</p>
<p>If there are more than count events already queued - all extra events will be immediately discarded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td></td></tr>
    <tr><td class="paramname">count</td><td>Maximum number of events to store for synchronous readout </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="aura_8c_source.html#l00711">711</a> of file <a class="el" href="aura_8c_source.html">aura.c</a>.</p>

<p>References <a class="el" href="buffer_8c_source.html#l00080">aura_buffer_release()</a>, and <a class="el" href="aura_8c_source.html#l00753">aura_get_next_event()</a>.</p>

</div>
</div>
<a class="anchor" id="gabab6f720480063cc86a02c0ee9b26850"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int aura_get_next_event </td>
          <td>(</td>
          <td class="paramtype">struct aura_node *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct aura_object **&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structaura__buffer.html">aura_buffer</a> **&#160;</td>
          <td class="paramname"><em>retbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the next event from the synchronous event queue. If there is no events in queue - this function may block until the next event arrives.</p>
<p>If the node goes offline during waiting for event this function will return an error</p>
<p>The caller should not in any way modify or free the obj pointer. The obj pointer returned will may not be valid after the next synchronous call (e.g. if the node went offline and back online) so do not rely on that in your application.</p>
<p>The caller should free the retbuf pointer with aura_buffer_release when it is no longer needed</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td></td></tr>
    <tr><td class="paramname">obj</td><td></td></tr>
    <tr><td class="paramname">retbuf</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the event has been read out. </dd></dl>

<p>Definition at line <a class="el" href="aura_8c_source.html#l00753">753</a> of file <a class="el" href="aura_8c_source.html">aura.c</a>.</p>

<p>References <a class="el" href="queue_8c_source.html#l00045">aura_dequeue_buffer()</a>, and <a class="el" href="eventloop_8c_source.html#l00201">aura_handle_events()</a>.</p>

<p>Referenced by <a class="el" href="aura_8c_source.html#l00711">aura_enable_sync_events()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5e49c5b1ff963835e12eacd49b11922a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int aura_get_pending_events </td>
          <td>(</td>
          <td class="paramtype">struct aura_node *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of events currently in internal event queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="aura_8c_source.html#l00730">730</a> of file <a class="el" href="aura_8c_source.html">aura.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga5b6475daecfc524b94d47b451093e4f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void aura_wait_status </td>
          <td>(</td>
          <td class="paramtype">struct aura_node *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Block until node's status becomes one of the requested</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td></td></tr>
    <tr><td class="paramname">status</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="aura_8c_source.html#l00607">607</a> of file <a class="el" href="aura_8c_source.html">aura.c</a>.</p>

<p>References <a class="el" href="eventloop_8c_source.html#l00201">aura_handle_events()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Mar 29 2016 22:49:28 for aura by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
