<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>aura: The asynchronous API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">aura
   &#160;<span id="projectnumber">0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__async.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">The asynchronous API</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad6e0759bf9a8909bf8fa357804a1f7b7"><td class="memItemLeft" align="right" valign="top">const struct aura_object *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async.html#gad6e0759bf9a8909bf8fa357804a1f7b7">aura_get_current_object</a> (struct aura_node *node)</td></tr>
<tr class="memdesc:gad6e0759bf9a8909bf8fa357804a1f7b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the pointer to the current aura_object.  <a href="#gad6e0759bf9a8909bf8fa357804a1f7b7">More...</a><br /></td></tr>
<tr class="separator:gad6e0759bf9a8909bf8fa357804a1f7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ba73d84e5776bf01976fffb5437c822"><td class="memItemLeft" align="right" valign="top">struct aura_eventloop *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async.html#ga9ba73d84e5776bf01976fffb5437c822">aura_eventloop_get_data</a> (struct aura_node *node)</td></tr>
<tr class="separator:ga9ba73d84e5776bf01976fffb5437c822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58e6f3144710ea775ea9538626293c19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async.html#ga58e6f3144710ea775ea9538626293c19">aura_status_changed_cb</a> (struct aura_node *node, void(*cb)(struct aura_node *node, int newstatus, void *arg), void *arg)</td></tr>
<tr class="separator:ga58e6f3144710ea775ea9538626293c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a023fad5838a880fa12cf3f91831d3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async.html#ga4a023fad5838a880fa12cf3f91831d3b">aura_fd_changed_cb</a> (struct aura_node *node, void(*cb)(const struct aura_pollfds *fd, enum aura_fd_action act, void *arg), void *arg)</td></tr>
<tr class="separator:ga4a023fad5838a880fa12cf3f91831d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcf94143b45bef92b967396a307fc358"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async.html#gafcf94143b45bef92b967396a307fc358">aura_etable_changed_cb</a> (struct aura_node *node, void(*cb)(struct aura_node *node, struct aura_export_table *old, struct aura_export_table *new, void *arg), void *arg)</td></tr>
<tr class="separator:gafcf94143b45bef92b967396a307fc358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga698d7f6c58a1976a7c0a200a48793719"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async.html#ga698d7f6c58a1976a7c0a200a48793719">aura_unhandled_evt_cb</a> (struct aura_node *node, void(*cb)(struct aura_node *node, struct <a class="el" href="structaura__buffer.html">aura_buffer</a> *buf, void *arg), void *arg)</td></tr>
<tr class="separator:ga698d7f6c58a1976a7c0a200a48793719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24fbf448f9be81cdbd71ec5c7e25177c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async.html#ga24fbf448f9be81cdbd71ec5c7e25177c">aura_start_call_raw</a> (struct aura_node *node, int id, void(*calldonecb)(struct aura_node *dev, int status, struct <a class="el" href="structaura__buffer.html">aura_buffer</a> *ret, void *arg), void *arg,...)</td></tr>
<tr class="separator:ga24fbf448f9be81cdbd71ec5c7e25177c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c2b77524dbc821aece7aa8321125e8d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async.html#ga5c2b77524dbc821aece7aa8321125e8d">aura_set_event_callback_raw</a> (struct aura_node *node, int id, void(*calldonecb)(struct aura_node *dev, int status, struct <a class="el" href="structaura__buffer.html">aura_buffer</a> *ret, void *arg), void *arg)</td></tr>
<tr class="separator:ga5c2b77524dbc821aece7aa8321125e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a79bf044c789871b88a82c7d3a60bb7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async.html#ga0a79bf044c789871b88a82c7d3a60bb7">aura_set_event_callback</a> (struct aura_node *node, const char *event, void(*calldonecb)(struct aura_node *dev, int status, struct <a class="el" href="structaura__buffer.html">aura_buffer</a> *ret, void *arg), void *arg)</td></tr>
<tr class="separator:ga0a79bf044c789871b88a82c7d3a60bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98dcf314a2f2b851bac5b3784e8557c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async.html#ga98dcf314a2f2b851bac5b3784e8557c2">aura_start_call</a> (struct aura_node *node, const char *name, void(*calldonecb)(struct aura_node *dev, int status, struct <a class="el" href="structaura__buffer.html">aura_buffer</a> *ret, void *arg), void *arg,...)</td></tr>
<tr class="separator:ga98dcf314a2f2b851bac5b3784e8557c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>If you are reading this, you must be familiar with the concept of events and methods. If not have a look at the previous section that describes synchronous API. It has a nice overview of how things work.</p>
<p>In this section we'll be dealing with asynchronous API. In real life your target device may work at speeds of several Mhz and take ages (compared to the host PC) to execute a method call. That's not cool, because we can do many other things while the remote side gets the job done.</p>
<p>With asynchronous API you can start a method call, and get the results in the supplied callback. Events also get delivered into their respective callbacks (if any).</p>
<p>If the node goes offline and later becomes live once more with a different export table, aura will try to preserve all of the event callbacks, even if their id changes. The callback will only get unregistered if event signature changes (e.g. the number or type of the returned values changes)</p>
<p>All of the callbacks are delivered from the eventloop. aura comes with it's own easy to use event loop implementation that is covered in the next section. The general workflow is:</p>
<ul>
<li>Open one or several nodes using <a class="el" href="group__node.html#ga5cd310198b9c3c4611a33891df799b62">aura_open()</a> or aura_vopen()</li>
<li>Register all of your callbacks</li>
<li>Create an eventloop using <a class="el" href="group__loop.html#ga9fad46eaf4490250562dfa6d121e649f">aura_eventloop_create()</a></li>
<li>Run the event processing loop with <a class="el" href="group__loop.html#gaa8e685df0d9bf78058cfbdd55a072813">aura_handle_events()</a> for as long as you want</li>
</ul>
<p>If you wish to integrate aura with your own event loop, see aura_get_pollfds() to get a list of descriptors to poll and <a class="el" href="group__async.html#ga4a023fad5838a880fa12cf3f91831d3b">aura_fd_changed_cb()</a> to get notified whenever transport expects a descriptor to be added/removed. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gafcf94143b45bef92b967396a307fc358"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void aura_etable_changed_cb </td>
          <td>(</td>
          <td class="paramtype">struct aura_node *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(struct aura_node *node, struct aura_export_table *old, struct aura_export_table *new, void *arg)&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set up etable changed callback. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td></td></tr>
    <tr><td class="paramname">cb</td><td></td></tr>
    <tr><td class="paramname">arg</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="aura_8c_source.html#l00295">295</a> of file <a class="el" href="aura_8c_source.html">aura.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga9ba73d84e5776bf01976fffb5437c822"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct aura_eventloop* aura_eventloop_get_data </td>
          <td>(</td>
          <td class="paramtype">struct aura_node *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the eventloop associated with this node</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to node's eventloop or NULL if node has none </dd></dl>

<p>Definition at line <a class="el" href="aura_8c_source.html#l00243">243</a> of file <a class="el" href="aura_8c_source.html">aura.c</a>.</p>

<p>Referenced by <a class="el" href="aura_8c_source.html#l00102">aura_close()</a>, <a class="el" href="eventloop_8c_source.html#l00038">aura_eventloop_add()</a>, and <a class="el" href="eventloop_8c_source.html#l00069">aura_eventloop_del()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4a023fad5838a880fa12cf3f91831d3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void aura_fd_changed_cb </td>
          <td>(</td>
          <td class="paramtype">struct aura_node *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(const struct aura_pollfds *fd, enum aura_fd_action act, void *arg)&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the fd changed callback. You don't need this call unless you're using your own eventsystem. Setting this callback will trigger callbacks for all the file descriptors that are already registered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td></td></tr>
    <tr><td class="paramname">cb</td><td></td></tr>
    <tr><td class="paramname">arg</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="aura_8c_source.html#l00275">275</a> of file <a class="el" href="aura_8c_source.html">aura.c</a>.</p>

<p>Referenced by <a class="el" href="eventloop_8c_source.html#l00038">aura_eventloop_add()</a>, and <a class="el" href="eventloop_8c_source.html#l00069">aura_eventloop_del()</a>.</p>

</div>
</div>
<a class="anchor" id="gad6e0759bf9a8909bf8fa357804a1f7b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct aura_object* aura_get_current_object </td>
          <td>(</td>
          <td class="paramtype">struct aura_node *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the pointer to the current aura_object. </p>
<p>This function can be used while in the callback to get the pointer to the struct aura_object that caused this callback.</p>
<p>Calling this function outside the callback will return NULL and spit out a warning to the log</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="aura_8c_source.html#l00226">226</a> of file <a class="el" href="aura_8c_source.html">aura.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga0a79bf044c789871b88a82c7d3a60bb7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int aura_set_event_callback </td>
          <td>(</td>
          <td class="paramtype">struct aura_node *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(struct aura_node *dev, int status, struct <a class="el" href="structaura__buffer.html">aura_buffer</a> *ret, void *arg)&#160;</td>
          <td class="paramname"><em>calldonecb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the callback that will be called when event with supplied name arrives. NULL calldonecb disables this event callback. <a class="el" href="structaura__buffer.html">aura_buffer</a> supplied to called in 'ret' contains any data assiciated with this event. You should not free the data buffer in the callback or access the buffer from anywhere but this callback. Make a copy if you need it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td></td></tr>
    <tr><td class="paramname">event</td><td></td></tr>
    <tr><td class="paramname">calldonecb</td><td></td></tr>
    <tr><td class="paramname">arg</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="aura_8c_source.html#l00536">536</a> of file <a class="el" href="aura_8c_source.html">aura.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga5c2b77524dbc821aece7aa8321125e8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int aura_set_event_callback_raw </td>
          <td>(</td>
          <td class="paramtype">struct aura_node *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(struct aura_node *dev, int status, struct <a class="el" href="structaura__buffer.html">aura_buffer</a> *ret, void *arg)&#160;</td>
          <td class="paramname"><em>calldonecb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the callback that will be called when event with supplied id arrives. NULL calldonecb disables this event callback. <a class="el" href="structaura__buffer.html">aura_buffer</a> supplied to called in 'ret' contains any data assiciated with this event. You should not free the data buffer in the callback or access the buffer from anywhere but this callback. Make a copy if you need it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td></td></tr>
    <tr><td class="paramname">id</td><td></td></tr>
    <tr><td class="paramname">calldonecb</td><td></td></tr>
    <tr><td class="paramname">arg</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="aura_8c_source.html#l00505">505</a> of file <a class="el" href="aura_8c_source.html">aura.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga98dcf314a2f2b851bac5b3784e8557c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int aura_start_call </td>
          <td>(</td>
          <td class="paramtype">struct aura_node *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(struct aura_node *dev, int status, struct <a class="el" href="structaura__buffer.html">aura_buffer</a> *ret, void *arg)&#160;</td>
          <td class="paramname"><em>calldonecb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start a call to an object identified by name. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td></td></tr>
    <tr><td class="paramname">name</td><td></td></tr>
    <tr><td class="paramname">calldonecb</td><td></td></tr>
    <tr><td class="paramname">arg</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-EBADSLT if the requested id is not in etable -EIO if serialization failed or another synchronous call for this id is pending -ENOEXEC if the node is currently offline </dd></dl>

<p>Definition at line <a class="el" href="aura_8c_source.html#l00564">564</a> of file <a class="el" href="aura_8c_source.html">aura.c</a>.</p>

<p>References <a class="el" href="buffer_8c_source.html#l00080">aura_buffer_release()</a>, and <a class="el" href="aura_8c_source.html#l00361">aura_core_start_call()</a>.</p>

</div>
</div>
<a class="anchor" id="ga24fbf448f9be81cdbd71ec5c7e25177c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int aura_start_call_raw </td>
          <td>(</td>
          <td class="paramtype">struct aura_node *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(struct aura_node *dev, int status, struct <a class="el" href="structaura__buffer.html">aura_buffer</a> *ret, void *arg)&#160;</td>
          <td class="paramname"><em>calldonecb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start a call for the object identified by its id the export table. Upon completion the specified callback will be fired with call results.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td></td></tr>
    <tr><td class="paramname">id</td><td></td></tr>
    <tr><td class="paramname">calldonecb</td><td></td></tr>
    <tr><td class="paramname">arg</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-EBADSLT if the requested id is not in etable -EIO if serialization failed or another synchronous call for this id is pending -ENOEXEC if the node is currently offline </dd></dl>

<p>Definition at line <a class="el" href="aura_8c_source.html#l00462">462</a> of file <a class="el" href="aura_8c_source.html">aura.c</a>.</p>

<p>References <a class="el" href="buffer_8c_source.html#l00080">aura_buffer_release()</a>, and <a class="el" href="aura_8c_source.html#l00361">aura_core_start_call()</a>.</p>

</div>
</div>
<a class="anchor" id="ga58e6f3144710ea775ea9538626293c19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void aura_status_changed_cb </td>
          <td>(</td>
          <td class="paramtype">struct aura_node *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(struct aura_node *node, int newstatus, void *arg)&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Setup the status change callback. This callback will be called when the node goes online and offline</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td></td></tr>
    <tr><td class="paramname">cb</td><td></td></tr>
    <tr><td class="paramname">arg</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="aura_8c_source.html#l00258">258</a> of file <a class="el" href="aura_8c_source.html">aura.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga698d7f6c58a1976a7c0a200a48793719"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void aura_unhandled_evt_cb </td>
          <td>(</td>
          <td class="paramtype">struct aura_node *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(struct aura_node *node, struct <a class="el" href="structaura__buffer.html">aura_buffer</a> *buf, void *arg)&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set up a generic callback to catch all events that have no callbacks installed. Warning: This callback will not be called if you enable synchronous event processing</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td></td></tr>
    <tr><td class="paramname">cb</td><td>The callback function to call </td></tr>
    <tr><td class="paramname">arg</td><td>Argument that will be passed to the callback function </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="aura_8c_source.html#l00314">314</a> of file <a class="el" href="aura_8c_source.html">aura.c</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Mar 29 2016 22:49:28 for aura by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
