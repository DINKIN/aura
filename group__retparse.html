<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>aura: Parsing return values</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">aura
   &#160;<span id="projectnumber">0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__retparse.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Parsing return values</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga224a1964b81bf3c4533e03e189d7b8ec"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__retparse.html#ga224a1964b81bf3c4533e03e189d7b8ec">aura_buffer_get_u8</a> (struct <a class="el" href="structaura__buffer.html">aura_buffer</a> *buf)</td></tr>
<tr class="memdesc:ga224a1964b81bf3c4533e03e189d7b8ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an unsigned 8 bit integer from aura buffer.  <a href="#ga224a1964b81bf3c4533e03e189d7b8ec">More...</a><br /></td></tr>
<tr class="separator:ga224a1964b81bf3c4533e03e189d7b8ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ba5717e55cc9c86046ba93977f8af8c"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__retparse.html#ga9ba5717e55cc9c86046ba93977f8af8c">aura_buffer_get_u16</a> (struct <a class="el" href="structaura__buffer.html">aura_buffer</a> *buf)</td></tr>
<tr class="memdesc:ga9ba5717e55cc9c86046ba93977f8af8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an unsigned 16 bit integer from aura buffer.  <a href="#ga9ba5717e55cc9c86046ba93977f8af8c">More...</a><br /></td></tr>
<tr class="separator:ga9ba5717e55cc9c86046ba93977f8af8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga287c5fe0f5b9ca9aa1d788ad3cb2f2ec"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__retparse.html#ga287c5fe0f5b9ca9aa1d788ad3cb2f2ec">aura_buffer_get_u32</a> (struct <a class="el" href="structaura__buffer.html">aura_buffer</a> *buf)</td></tr>
<tr class="memdesc:ga287c5fe0f5b9ca9aa1d788ad3cb2f2ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an unsigned 32 bit integer from aura buffer.  <a href="#ga287c5fe0f5b9ca9aa1d788ad3cb2f2ec">More...</a><br /></td></tr>
<tr class="separator:ga287c5fe0f5b9ca9aa1d788ad3cb2f2ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cb71911afd5879cced6f6cb6fd31258"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__retparse.html#ga4cb71911afd5879cced6f6cb6fd31258">aura_buffer_get_u64</a> (struct <a class="el" href="structaura__buffer.html">aura_buffer</a> *buf)</td></tr>
<tr class="memdesc:ga4cb71911afd5879cced6f6cb6fd31258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an unsigned 64 bit integer from aura buffer.  <a href="#ga4cb71911afd5879cced6f6cb6fd31258">More...</a><br /></td></tr>
<tr class="separator:ga4cb71911afd5879cced6f6cb6fd31258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga350dec1b895aec5a48501e737f688c44"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__retparse.html#ga350dec1b895aec5a48501e737f688c44">aura_buffer_get_s8</a> (struct <a class="el" href="structaura__buffer.html">aura_buffer</a> *buf)</td></tr>
<tr class="memdesc:ga350dec1b895aec5a48501e737f688c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a signed 8 bit integer from aura buffer.  <a href="#ga350dec1b895aec5a48501e737f688c44">More...</a><br /></td></tr>
<tr class="separator:ga350dec1b895aec5a48501e737f688c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a7e8ccfca07e5e5e7adfcb828db3e41"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__retparse.html#ga3a7e8ccfca07e5e5e7adfcb828db3e41">aura_buffer_get_s16</a> (struct <a class="el" href="structaura__buffer.html">aura_buffer</a> *buf)</td></tr>
<tr class="memdesc:ga3a7e8ccfca07e5e5e7adfcb828db3e41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a signed 16 bit integer from aura buffer.  <a href="#ga3a7e8ccfca07e5e5e7adfcb828db3e41">More...</a><br /></td></tr>
<tr class="separator:ga3a7e8ccfca07e5e5e7adfcb828db3e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fd40a22d0f378359d120ff28b5a7457"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__retparse.html#ga4fd40a22d0f378359d120ff28b5a7457">aura_buffer_get_s32</a> (struct <a class="el" href="structaura__buffer.html">aura_buffer</a> *buf)</td></tr>
<tr class="memdesc:ga4fd40a22d0f378359d120ff28b5a7457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a signed 32 bit integer from aura buffer.  <a href="#ga4fd40a22d0f378359d120ff28b5a7457">More...</a><br /></td></tr>
<tr class="separator:ga4fd40a22d0f378359d120ff28b5a7457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga823a57cb1bb0010fd4ef6b481715508d"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__retparse.html#ga823a57cb1bb0010fd4ef6b481715508d">aura_buffer_get_s64</a> (struct <a class="el" href="structaura__buffer.html">aura_buffer</a> *buf)</td></tr>
<tr class="memdesc:ga823a57cb1bb0010fd4ef6b481715508d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a signed 64 bit integer from aura buffer.  <a href="#ga823a57cb1bb0010fd4ef6b481715508d">More...</a><br /></td></tr>
<tr class="separator:ga823a57cb1bb0010fd4ef6b481715508d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4c6d143180f0106b41fde3b54880f67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__retparse.html#gab4c6d143180f0106b41fde3b54880f67">aura_buffer_put_u8</a> (struct <a class="el" href="structaura__buffer.html">aura_buffer</a> *buf, uint8_t value)</td></tr>
<tr class="memdesc:gab4c6d143180f0106b41fde3b54880f67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put an unsigned 8 bit integer to aura buffer.  <a href="#gab4c6d143180f0106b41fde3b54880f67">More...</a><br /></td></tr>
<tr class="separator:gab4c6d143180f0106b41fde3b54880f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga403d88181c88ddee399a3133ab0c94c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__retparse.html#ga403d88181c88ddee399a3133ab0c94c8">aura_buffer_put_u16</a> (struct <a class="el" href="structaura__buffer.html">aura_buffer</a> *buf, uint16_t value)</td></tr>
<tr class="memdesc:ga403d88181c88ddee399a3133ab0c94c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put an unsigned 16 bit integer to aura buffer.  <a href="#ga403d88181c88ddee399a3133ab0c94c8">More...</a><br /></td></tr>
<tr class="separator:ga403d88181c88ddee399a3133ab0c94c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f45b35331af0c7ab19ab5cdf6c211e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__retparse.html#ga5f45b35331af0c7ab19ab5cdf6c211e0">aura_buffer_put_u32</a> (struct <a class="el" href="structaura__buffer.html">aura_buffer</a> *buf, uint32_t value)</td></tr>
<tr class="memdesc:ga5f45b35331af0c7ab19ab5cdf6c211e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put an unsigned 32 bit integer to aura buffer.  <a href="#ga5f45b35331af0c7ab19ab5cdf6c211e0">More...</a><br /></td></tr>
<tr class="separator:ga5f45b35331af0c7ab19ab5cdf6c211e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5a1a7928354743c6c6f7846be690728"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__retparse.html#gac5a1a7928354743c6c6f7846be690728">aura_buffer_put_u64</a> (struct <a class="el" href="structaura__buffer.html">aura_buffer</a> *buf, uint64_t value)</td></tr>
<tr class="memdesc:gac5a1a7928354743c6c6f7846be690728"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put an unsigned 64 bit integer to aura buffer.  <a href="#gac5a1a7928354743c6c6f7846be690728">More...</a><br /></td></tr>
<tr class="separator:gac5a1a7928354743c6c6f7846be690728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dc198d7bbe85eb15e22cd58de77a0d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__retparse.html#ga5dc198d7bbe85eb15e22cd58de77a0d0">aura_buffer_put_s8</a> (struct <a class="el" href="structaura__buffer.html">aura_buffer</a> *buf, int8_t value)</td></tr>
<tr class="memdesc:ga5dc198d7bbe85eb15e22cd58de77a0d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put a signed 8 bit integer to aura buffer.  <a href="#ga5dc198d7bbe85eb15e22cd58de77a0d0">More...</a><br /></td></tr>
<tr class="separator:ga5dc198d7bbe85eb15e22cd58de77a0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca8be6556aa077028c9ab81d30a58a2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__retparse.html#gaca8be6556aa077028c9ab81d30a58a2a">aura_buffer_put_s16</a> (struct <a class="el" href="structaura__buffer.html">aura_buffer</a> *buf, int16_t value)</td></tr>
<tr class="memdesc:gaca8be6556aa077028c9ab81d30a58a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put a signed 16 bit integer to aura buffer.  <a href="#gaca8be6556aa077028c9ab81d30a58a2a">More...</a><br /></td></tr>
<tr class="separator:gaca8be6556aa077028c9ab81d30a58a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d01cd9a1f46a3cd11c02aa20b456db8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__retparse.html#ga2d01cd9a1f46a3cd11c02aa20b456db8">aura_buffer_put_s32</a> (struct <a class="el" href="structaura__buffer.html">aura_buffer</a> *buf, int32_t value)</td></tr>
<tr class="memdesc:ga2d01cd9a1f46a3cd11c02aa20b456db8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put a signed 32 bit integer to aura buffer.  <a href="#ga2d01cd9a1f46a3cd11c02aa20b456db8">More...</a><br /></td></tr>
<tr class="separator:ga2d01cd9a1f46a3cd11c02aa20b456db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac224f5e70c8d38714468ed5f222c4a09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__retparse.html#gac224f5e70c8d38714468ed5f222c4a09">aura_buffer_put_s64</a> (struct <a class="el" href="structaura__buffer.html">aura_buffer</a> *buf, int64_t value)</td></tr>
<tr class="memdesc:gac224f5e70c8d38714468ed5f222c4a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put a signed 64 bit integer to aura buffer.  <a href="#gac224f5e70c8d38714468ed5f222c4a09">More...</a><br /></td></tr>
<tr class="separator:gac224f5e70c8d38714468ed5f222c4a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fffd8d51a2e6de0b39fe63d839e51ae"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__retparse.html#ga7fffd8d51a2e6de0b39fe63d839e51ae">aura_buffer_get_bin</a> (struct <a class="el" href="structaura__buffer.html">aura_buffer</a> *buf, int len)</td></tr>
<tr class="memdesc:ga7fffd8d51a2e6de0b39fe63d839e51ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the binary data block within buffer and advance internal pointer by len bytes. The data in the buffer is managed internally and should not be freed by the caller.  <a href="#ga7fffd8d51a2e6de0b39fe63d839e51ae">More...</a><br /></td></tr>
<tr class="separator:ga7fffd8d51a2e6de0b39fe63d839e51ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ce9c998f858188cda6a08b167d03dd4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__retparse.html#ga2ce9c998f858188cda6a08b167d03dd4">aura_buffer_put_bin</a> (struct <a class="el" href="structaura__buffer.html">aura_buffer</a> *buf, const void *data, int len)</td></tr>
<tr class="memdesc:ga2ce9c998f858188cda6a08b167d03dd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data of len bytes to aura buffer from a buffer pointed by data.  <a href="#ga2ce9c998f858188cda6a08b167d03dd4">More...</a><br /></td></tr>
<tr class="separator:ga2ce9c998f858188cda6a08b167d03dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18a959286df58d3fe6803d63276a1bd6"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structaura__buffer.html">aura_buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__retparse.html#ga18a959286df58d3fe6803d63276a1bd6">aura_buffer_get_buf</a> (struct <a class="el" href="structaura__buffer.html">aura_buffer</a> *buf)</td></tr>
<tr class="memdesc:ga18a959286df58d3fe6803d63276a1bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve <a class="el" href="structaura__buffer.html">aura_buffer</a> pointer from within the buffer and advance internal pointer by it's size.  <a href="#ga18a959286df58d3fe6803d63276a1bd6">More...</a><br /></td></tr>
<tr class="separator:ga18a959286df58d3fe6803d63276a1bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga407808ac2228dea5fb117f985ac78570"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__retparse.html#ga407808ac2228dea5fb117f985ac78570">aura_buffer_get_ptr</a> (struct <a class="el" href="structaura__buffer.html">aura_buffer</a> *buf)</td></tr>
<tr class="separator:ga407808ac2228dea5fb117f985ac78570"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Events and methods deliver data in a struct <a class="el" href="structaura__buffer.html">aura_buffer</a> that should be used as opaque type. The functions documented in this section should be used to parse the buffer obtained from a device. These functions take care to swap endianness if required.</p>
<p>Aura buffers have internal pointer that is advanced by the number of bytes required when each argument is read out. Attempting to cross the buffer boundary will result in aura_panic() on the relevant node.</p>
<p>Although you may normally never need those, for some cases (e.g. writing bindings) a set of functions is provided to put values into aura buffers. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga7fffd8d51a2e6de0b39fe63d839e51ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void* aura_buffer_get_bin </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaura__buffer.html">aura_buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the binary data block within buffer and advance internal pointer by len bytes. The data in the buffer is managed internally and should not be freed by the caller. </p>
<p>This function will cause a panic if attempted to read beyond the buffer boundary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>aura buffer </td></tr>
    <tr><td class="paramname">len</td><td>data length </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="retparse_8c_source.html#l00060">60</a> of file <a class="el" href="retparse_8c_source.html">retparse.c</a>.</p>

<p>References <a class="el" href="aura_8h_source.html#l00347">aura_buffer::data</a>, <a class="el" href="aura_8h_source.html#l00343">aura_buffer::owner</a>, <a class="el" href="aura_8h_source.html#l00339">aura_buffer::pos</a>, and <a class="el" href="aura_8h_source.html#l00337">aura_buffer::size</a>.</p>

</div>
</div>
<a class="anchor" id="ga18a959286df58d3fe6803d63276a1bd6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structaura__buffer.html">aura_buffer</a>* aura_buffer_get_buf </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaura__buffer.html">aura_buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve <a class="el" href="structaura__buffer.html">aura_buffer</a> pointer from within the buffer and advance internal pointer by it's size. </p>
<p>The underlying transport must support passing <a class="el" href="structaura__buffer.html">aura_buffer</a> as arguments</p>
<p>This function will cause a panic if attempted to read beyond the buffer boundary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>aura buffer </td></tr>
    <tr><td class="paramname">len</td><td>data length </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="retparse_8c_source.html#l00083">83</a> of file <a class="el" href="retparse_8c_source.html">retparse.c</a>.</p>

<p>References <a class="el" href="aura_8h_source.html#l00335">aura_buffer::magic</a>, and <a class="el" href="aura_8h_source.html#l00343">aura_buffer::owner</a>.</p>

</div>
</div>
<a class="anchor" id="ga407808ac2228dea5fb117f985ac78570"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void* aura_buffer_get_ptr </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaura__buffer.html">aura_buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve transport-specific pointer from aura buffer. Handling of this data-type is transport specific.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3a7e8ccfca07e5e5e7adfcb828db3e41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t aura_buffer_get_s16 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaura__buffer.html">aura_buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a signed 16 bit integer from aura buffer. </p>
<p>This function will swap endianness if needed. This function will cause a panic if attempted to read beyond the buffer boundary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ga4fd40a22d0f378359d120ff28b5a7457"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t aura_buffer_get_s32 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaura__buffer.html">aura_buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a signed 32 bit integer from aura buffer. </p>
<p>This function will swap endianness if needed. This function will cause a panic if attempted to read beyound the buffer boundary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ga823a57cb1bb0010fd4ef6b481715508d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t aura_buffer_get_s64 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaura__buffer.html">aura_buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a signed 64 bit integer from aura buffer. </p>
<p>This function will swap endianness if needed. This function will cause a panic if attempted to read beyond the buffer boundary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ga350dec1b895aec5a48501e737f688c44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t aura_buffer_get_s8 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaura__buffer.html">aura_buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a signed 8 bit integer from aura buffer. </p>
<p>This function will cause a panic if attempted to read beyond the buffer boundary. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ga9ba5717e55cc9c86046ba93977f8af8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t aura_buffer_get_u16 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaura__buffer.html">aura_buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an unsigned 16 bit integer from aura buffer. </p>
<p>This function will swap endianness if needed. This function will cause a panic if attempted to read beyond the buffer boundary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ga287c5fe0f5b9ca9aa1d788ad3cb2f2ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t aura_buffer_get_u32 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaura__buffer.html">aura_buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an unsigned 32 bit integer from aura buffer. </p>
<p>This function will swap endianness if needed. This function will cause a panic if attempted to read beyond the buffer boundary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ga4cb71911afd5879cced6f6cb6fd31258"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t aura_buffer_get_u64 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaura__buffer.html">aura_buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an unsigned 64 bit integer from aura buffer. </p>
<p>This function will swap endianness if needed. This function will cause a panic if attempted to read beyond the buffer boundary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ga224a1964b81bf3c4533e03e189d7b8ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t aura_buffer_get_u8 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaura__buffer.html">aura_buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an unsigned 8 bit integer from aura buffer. </p>
<p>This function will cause a panic if attempted to read beyond the buffer boundary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ga2ce9c998f858188cda6a08b167d03dd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void aura_buffer_put_bin </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaura__buffer.html">aura_buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy data of len bytes to aura buffer from a buffer pointed by data. </p>
<p>This function will advance internal <a class="el" href="structaura__buffer.html">aura_buffer</a> pointer by len bytes.</p>
<p>This function will cause a panic if attempted to read beyond the buffer boundary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>aura buffer </td></tr>
    <tr><td class="paramname">data</td><td>data buffer </td></tr>
    <tr><td class="paramname">len</td><td>data length </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="retparse_8c_source.html#l00071">71</a> of file <a class="el" href="retparse_8c_source.html">retparse.c</a>.</p>

<p>References <a class="el" href="aura_8h_source.html#l00347">aura_buffer::data</a>, <a class="el" href="aura_8h_source.html#l00343">aura_buffer::owner</a>, <a class="el" href="aura_8h_source.html#l00339">aura_buffer::pos</a>, and <a class="el" href="aura_8h_source.html#l00337">aura_buffer::size</a>.</p>

</div>
</div>
<a class="anchor" id="gaca8be6556aa077028c9ab81d30a58a2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void aura_buffer_put_s16 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaura__buffer.html">aura_buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put a signed 16 bit integer to aura buffer. </p>
<p>This function will swap endianness if needed. This function will cause a panic if attempted to read beyond the buffer boundary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td></td></tr>
    <tr><td class="paramname">value</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ga2d01cd9a1f46a3cd11c02aa20b456db8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void aura_buffer_put_s32 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaura__buffer.html">aura_buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put a signed 32 bit integer to aura buffer. </p>
<p>This function will swap endianness if needed. This function will cause a panic if attempted to read beyound the buffer boundary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td></td></tr>
    <tr><td class="paramname">value</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="gac224f5e70c8d38714468ed5f222c4a09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void aura_buffer_put_s64 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaura__buffer.html">aura_buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put a signed 64 bit integer to aura buffer. </p>
<p>This function will swap endianness if needed. This function will cause a panic if attempted to read beyond the buffer boundary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td></td></tr>
    <tr><td class="paramname">value</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ga5dc198d7bbe85eb15e22cd58de77a0d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void aura_buffer_put_s8 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaura__buffer.html">aura_buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put a signed 8 bit integer to aura buffer. </p>
<p>This function will cause a panic if attempted to read beyond the buffer boundary. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td></td></tr>
    <tr><td class="paramname">value</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ga403d88181c88ddee399a3133ab0c94c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void aura_buffer_put_u16 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaura__buffer.html">aura_buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put an unsigned 16 bit integer to aura buffer. </p>
<p>This function will swap endianness if needed. This function will cause a panic if attempted to read beyond the buffer boundary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td></td></tr>
    <tr><td class="paramname">value</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ga5f45b35331af0c7ab19ab5cdf6c211e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void aura_buffer_put_u32 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaura__buffer.html">aura_buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put an unsigned 32 bit integer to aura buffer. </p>
<p>This function will swap endianness if needed. This function will cause a panic if attempted to read beyond the buffer boundary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td></td></tr>
    <tr><td class="paramname">value</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="gac5a1a7928354743c6c6f7846be690728"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void aura_buffer_put_u64 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaura__buffer.html">aura_buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put an unsigned 64 bit integer to aura buffer. </p>
<p>This function will swap endianness if needed. This function will cause a panic if attempted to read beyond the buffer boundary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td></td></tr>
    <tr><td class="paramname">value</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="gab4c6d143180f0106b41fde3b54880f67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void aura_buffer_put_u8 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structaura__buffer.html">aura_buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put an unsigned 8 bit integer to aura buffer. </p>
<p>This function will cause a panic if attempted to read beyond the buffer boundary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td></td></tr>
    <tr><td class="paramname">value</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Mar 29 2016 22:49:28 for aura by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
